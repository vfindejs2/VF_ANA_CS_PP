<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Konceptualni model — PasPort (PP) — Cyklicke svozy CS</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
            color: #1a1a2e;
            padding: 32px;
        }
        h1 { font-size: 1.5rem; margin-bottom: 4px; }
        .subtitle { color: #666; font-size: 0.9rem; margin-bottom: 20px; }
        .legend {
            display: flex;
            gap: 20px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
        }
        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            border: 1px solid rgba(0,0,0,0.2);
        }
        .diagram-container {
            background: white;
            border-radius: 10px;
            padding: 32px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            overflow: auto;
        }
        .note {
            margin-top: 16px;
            padding: 12px 16px;
            background: #f0f0f0;
            border-left: 4px solid #888;
            border-radius: 4px;
            font-size: 0.84rem;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <h1>Konceptualni model: PasPort (PP)</h1>
    <p class="subtitle">Cyklicke svozy MP SK | Business pohled — entity a jejich vazby bez atributu</p>

    <div class="legend">
        <div class="legend-item"><div class="legend-color" style="background: #3b82f6;"></div><span>Stavajici entita (beze zmen)</span></div>
        <div class="legend-item"><div class="legend-color" style="background: #f59e0b;"></div><span>Stavajici entita (upravena pro CS)</span></div>
        <div class="legend-item"><div class="legend-color" style="background: #22c55e;"></div><span>Nova entita — Etapa 1</span></div>
        <div class="legend-item"><div class="legend-color" style="background: #a855f7;"></div><span>Nova entita — Etapa 2</span></div>
        <div class="legend-item"><div class="legend-color" style="background: #ef4444;"></div><span>Externi system (HEN)</span></div>
    </div>

    <div class="diagram-container">
        <div id="diagram"></div>
    </div>

    <div class="note">
        <strong>Jak cist diagram:</strong> Plne cary = stavajici vazby. Carkove cary = nove vazby pro CS.
        Cisla u vztahu (napr. A1, A4) odkazuji na pozadavky z Ciloveho konceptu.
        Tluste oramovane entity jsou nove. Tenke oramovane jsou stavajici. Sipky ukazuji smer FK (podrizena → nadrizena).
    </div>

    <script>
    const SVG_NS = 'http://www.w3.org/2000/svg';

    // --- Entity definitions ---
    const entities = [
        // Existing unchanged
        { id: 'order',          label: 'Objednavka',                    x: 80,  y: 60,  color: '#3b82f6', type: 'existing' },
        { id: 'order_item',     label: 'Polozka\nobjednavky',           x: 80,  y: 170, color: '#3b82f6', type: 'existing' },
        { id: 'site',           label: 'Stanoviste',                    x: 580, y: 420, color: '#3b82f6', type: 'existing' },
        { id: 'org_unit',       label: 'Provozovna',                    x: 580, y: 60,  color: '#3b82f6', type: 'existing' },
        { id: 'wdd',            label: 'Zakladni dny\nsvozu',          x: 80,  y: 520, color: '#3b82f6', type: 'existing' },
        { id: 'wdf',            label: 'Frekvence\nvyvozu',            x: 80,  y: 420, color: '#3b82f6', type: 'existing' },
        // Existing modified
        { id: 'rpo',            label: 'Revize polozky\nobjednavky (RPO)', x: 260, y: 280, color: '#f59e0b', type: 'modified', w: 180 },
        { id: 'container',      label: 'Nadoba',                       x: 580, y: 280, color: '#f59e0b', type: 'modified' },
        { id: 'garbage_group',  label: 'Skupina\nodpadu',              x: 580, y: 170, color: '#f59e0b', type: 'modified' },
        { id: 'garbage_type',   label: 'Druh odpadu',                  x: 780, y: 170, color: '#f59e0b', type: 'modified' },
        { id: 'container_type', label: 'Typ nadoby',                   x: 780, y: 280, color: '#f59e0b', type: 'modified' },
        { id: 'address',        label: 'Adresa',                       x: 780, y: 420, color: '#f59e0b', type: 'modified' },
        // New Etapa 1
        { id: 'circuit',        label: 'Okruh',                        x: 80,  y: 280, color: '#22c55e', type: 'new' },
        { id: 'schedule',       label: 'Rozvrh',                       x: 260, y: 420, color: '#22c55e', type: 'new' },
        { id: 'schedule_day',   label: 'Kalendarni den\nrozvrhu',      x: 260, y: 530, color: '#22c55e', type: 'new' },
        { id: 'zone',           label: 'Zona',                         x: 440, y: 170, color: '#22c55e', type: 'new' },
        // New Etapa 2
        { id: 'gg_ct_params',   label: 'Parametry\nsk.odp. + typ nab.', x: 780, y: 60, color: '#a855f7', type: 'new', w: 175 },
        // External
        { id: 'hen',            label: 'HEN\n(externi)',               x: 260, y: 60,  color: '#ef4444', type: 'external' },
    ];

    // --- Relationship definitions ---
    const relationships = [
        // Existing relationships (solid lines)
        { from: 'order_item',  to: 'order',          label: '1:N',       style: 'solid' },
        { from: 'rpo',         to: 'order_item',     label: '1:N',       style: 'solid' },
        { from: 'container',   to: 'container_type', label: 'N:1',       style: 'solid' },
        { from: 'container',   to: 'garbage_group',  label: 'N:1',       style: 'solid' },
        { from: 'container',   to: 'site',           label: 'M:N',       style: 'solid' },
        { from: 'container',   to: 'order_item',     label: 'M:N',       style: 'solid', path: [{x: 630, y: 198}] },
        { from: 'site',        to: 'address',        label: 'N:1',       style: 'solid' },
        { from: 'site',        to: 'org_unit',       label: 'N:1',       style: 'solid' },
        { from: 'rpo',         to: 'wdd',            label: 'M:N',       style: 'solid' },
        // New relationships (dashed lines)
        { from: 'rpo',         to: 'circuit',        label: 'M:N\n(A1)', style: 'dashed' },
        { from: 'rpo',         to: 'schedule',       label: 'M:N\n(A2)', style: 'dashed' },
        { from: 'rpo',         to: 'zone',           label: '1:1\n(A3)', style: 'dashed' },
        { from: 'rpo',         to: 'garbage_group',  label: 'N:1\n(A4)', style: 'dashed' },
        { from: 'garbage_type',to: 'garbage_group',  label: 'N:1\n(A4)', style: 'dashed' },
        { from: 'garbage_group',to: 'org_unit',      label: 'N:1\n(A4)', style: 'dashed' },
        { from: 'schedule',    to: 'schedule_day',   label: '1:N\n(A2)', style: 'dashed' },
        { from: 'circuit',     to: 'org_unit',       label: 'N:1',       style: 'dashed' },
        { from: 'schedule',    to: 'org_unit',       label: 'N:1',       style: 'dashed', path: [{x:480, y: 440}, {x: 480, y: 88}] },
        { from: 'zone',        to: 'org_unit',       label: 'N:1',       style: 'dashed' },
        { from: 'gg_ct_params',to: 'garbage_group',  label: 'N:1\n(A11)',style: 'dashed' },
        { from: 'gg_ct_params',to: 'container_type', label: 'N:1\n(A11)',style: 'dashed', path: [{x:868, y: 140}, {x:868, y: 258}] },
        // HEN sync
        { from: 'hen',         to: 'circuit',        label: 'sync',      style: 'dotted' },
        { from: 'hen',         to: 'schedule',       label: 'sync',      style: 'dotted', path: [{x: 310, y: 120}, {x: 310, y: 398}]  },
        { from: 'hen',         to: 'zone',           label: 'sync',      style: 'dotted' },
    ];

    // --- Render ---
    const W = 990, H = 600;
    const svg = document.createElementNS(SVG_NS, 'svg');
    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', H);
    svg.style.fontFamily = "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif";

    // Defs: arrowhead + dash patterns
    const defs = document.createElementNS(SVG_NS, 'defs');
    defs.innerHTML = `
        <marker id="arrow" viewBox="0 0 10 7" refX="10" refY="3.5" markerWidth="8" markerHeight="6" orient="auto-start-reverse">
            <polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8"/>
        </marker>
        <marker id="arrow-green" viewBox="0 0 10 7" refX="10" refY="3.5" markerWidth="8" markerHeight="6" orient="auto-start-reverse">
            <polygon points="0 0, 10 3.5, 0 7" fill="#22c55e"/>
        </marker>
        <marker id="arrow-red" viewBox="0 0 10 7" refX="10" refY="3.5" markerWidth="8" markerHeight="6" orient="auto-start-reverse">
            <polygon points="0 0, 10 3.5, 0 7" fill="#ef4444"/>
        </marker>
    `;
    svg.appendChild(defs);

    const ENTITY_W = 150, ENTITY_H = 50;

    function entityCenter(e) {
        const w = e.w || ENTITY_W;
        return { x: e.x + w/2, y: e.y + ENTITY_H/2 };
    }

    function entityEdgePoint(e, target) {
        const c = entityCenter(e);
        const w = (e.w || ENTITY_W)/2, h = ENTITY_H/2;
        const dx = target.x - c.x, dy = target.y - c.y;
        if (dx === 0 && dy === 0) return c;
        const absDx = Math.abs(dx), absDy = Math.abs(dy);
        let scale;
        if (absDx * h > absDy * w) {
            scale = w / absDx;
        } else {
            scale = h / absDy;
        }
        return { x: c.x + dx * scale, y: c.y + dy * scale };
    }

    // Draw relationships first (behind entities)
    relationships.forEach(r => {
        const eFrom = entities.find(e => e.id === r.from);
        const eTo = entities.find(e => e.id === r.to);
        if (!eFrom || !eTo) return;

        const cFrom = entityCenter(eFrom);
        const cTo = entityCenter(eTo);

        let points;
        if (r.path) {
            points = [cFrom, ...r.path, cTo];
        } else {
            points = [cFrom, cTo];
        }

        // Trim first/last segment to entity edge
        const pStart = entityEdgePoint(eFrom, points[1]);
        const pEnd = entityEdgePoint(eTo, points[points.length - 2]);
        points[0] = pStart;
        points[points.length - 1] = pEnd;

        const line = document.createElementNS(SVG_NS, 'polyline');
        line.setAttribute('points', points.map(p => `${p.x},${p.y}`).join(' '));
        line.setAttribute('fill', 'none');
        const color = r.style === 'dotted' ? '#ef4444' : r.style === 'dashed' ? '#22c55e' : '#94a3b8';
        line.setAttribute('stroke', color);
        line.setAttribute('stroke-width', r.style === 'solid' ? '1.5' : '2');
        if (r.style === 'dashed') line.setAttribute('stroke-dasharray', '8,4');
        if (r.style === 'dotted') line.setAttribute('stroke-dasharray', '3,3');
        const markerColor = r.style === 'dotted' ? 'arrow-red' : r.style === 'dashed' ? 'arrow-green' : 'arrow';
        line.setAttribute('marker-end', `url(#${markerColor})`);
        svg.appendChild(line);

        // Label at midpoint of middle segment
        const midIdx = Math.floor(points.length / 2);
        const mp = {
            x: (points[midIdx-1].x + points[midIdx].x) / 2,
            y: (points[midIdx-1].y + points[midIdx].y) / 2
        };
        const labelLines = r.label.split('\n');
        labelLines.forEach((txt, i) => {
            const t = document.createElementNS(SVG_NS, 'text');
            t.setAttribute('x', mp.x);
            t.setAttribute('y', mp.y - 4 + i * 13 - (labelLines.length-1)*6);
            t.setAttribute('text-anchor', 'middle');
            t.setAttribute('font-size', '10');
            t.setAttribute('fill', color);
            t.setAttribute('font-weight', i === 0 ? '600' : '400');

            // Background rect
            const bg = document.createElementNS(SVG_NS, 'rect');
            t.textContent = txt;
            svg.appendChild(t);
            const bbox = t.getBBox();
            bg.setAttribute('x', bbox.x - 2);
            bg.setAttribute('y', bbox.y - 1);
            bg.setAttribute('width', bbox.width + 4);
            bg.setAttribute('height', bbox.height + 2);
            bg.setAttribute('fill', 'white');
            bg.setAttribute('rx', '2');
            svg.insertBefore(bg, t);
        });
    });

    // Draw entities
    entities.forEach(e => {
        const w = e.w || ENTITY_W;
        const isNew = e.type === 'new' || e.type === 'external';
        const g = document.createElementNS(SVG_NS, 'g');

        // Shadow
        const shadow = document.createElementNS(SVG_NS, 'rect');
        shadow.setAttribute('x', e.x + 2);
        shadow.setAttribute('y', e.y + 2);
        shadow.setAttribute('width', w);
        shadow.setAttribute('height', ENTITY_H);
        shadow.setAttribute('rx', '8');
        shadow.setAttribute('fill', 'rgba(0,0,0,0.06)');
        g.appendChild(shadow);

        // Box
        const rect = document.createElementNS(SVG_NS, 'rect');
        rect.setAttribute('x', e.x);
        rect.setAttribute('y', e.y);
        rect.setAttribute('width', w);
        rect.setAttribute('height', ENTITY_H);
        rect.setAttribute('rx', '8');
        rect.setAttribute('fill', 'white');
        rect.setAttribute('stroke', e.color);
        rect.setAttribute('stroke-width', isNew ? '2.5' : '1.5');
        g.appendChild(rect);

        // Color bar top
        const bar = document.createElementNS(SVG_NS, 'rect');
        bar.setAttribute('x', e.x);
        bar.setAttribute('y', e.y);
        bar.setAttribute('width', w);
        bar.setAttribute('height', '5');
        bar.setAttribute('rx', '0');
        bar.setAttribute('fill', e.color);
        // Clip top corners
        const clip = document.createElementNS(SVG_NS, 'clipPath');
        clip.id = `clip-${e.id}`;
        const clipRect = document.createElementNS(SVG_NS, 'rect');
        clipRect.setAttribute('x', e.x);
        clipRect.setAttribute('y', e.y);
        clipRect.setAttribute('width', w);
        clipRect.setAttribute('height', ENTITY_H);
        clipRect.setAttribute('rx', '8');
        clip.appendChild(clipRect);
        defs.appendChild(clip);
        bar.setAttribute('clip-path', `url(#clip-${e.id})`);
        g.appendChild(bar);

        // Label (multiline)
        const lines = e.label.split('\n');
        const lineHeight = 14;
        const totalH = lines.length * lineHeight;
        const startY = e.y + ENTITY_H/2 - totalH/2 + lineHeight - 1;
        lines.forEach((line, i) => {
            const t = document.createElementNS(SVG_NS, 'text');
            t.setAttribute('x', e.x + w/2);
            t.setAttribute('y', startY + i * lineHeight);
            t.setAttribute('text-anchor', 'middle');
            t.setAttribute('font-size', '12');
            t.setAttribute('font-weight', '600');
            t.setAttribute('fill', '#1a1a2e');
            t.textContent = line;
            g.appendChild(t);
        });

        svg.appendChild(g);
    });

    document.getElementById('diagram').appendChild(svg);
    </script>
</body>
</html>
